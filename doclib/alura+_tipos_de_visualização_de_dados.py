# -*- coding: utf-8 -*-
"""Alura+ - Tipos de Visualiza√ß√£o de Dados.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/afonsosr2/alura_datavis/blob/main/Alura%2B_Tipos_de_Visualiza%C3%A7%C3%A3o_de_Dados.ipynb

# Alura+ -Tipos de Visualiza√ß√£o de Dados
---

## An√°lise dos Microdados do Enem (2010 - 2017)

> Regi√£o Nordeste (9 estados)
- Ano
- Unidade Federal (prova)
- Idade
- Situa√ß√£o de Conclus√£o
- Tipo de l√≠ngua
- Notas (Ci√™ncias da Natureza, Ci√™ncias Humanas, Linguagens, Matem√°tica e Reda√ß√£o)

### Importando as bibliotecas e carregando o arquivo
"""

# Importando as bibliotecas para manipula√ß√£o e visualiza√ß√£o de dados
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import plotly.express as px

# Carregando o arquivo dos microdados no ambiente como um Dataframe
enem = pd.read_csv("https://raw.githubusercontent.com/afonsosr2/alura_datavis/main/enem_nordeste_2010_2017.csv")

enem.head()

"""## Tipos de Visualiza√ß√£o

Para escolhermos o tipo de visualiza√ß√£o de nossos dados precisamos, nos perguntar primeiro **como** queremos represent√°-los e **o que** queremos informar ao nosso p√∫blico. 

Na imagem abaixo, apresentamos um diagrama com diversos tipos de **visualiza√ß√£o de dados** (criado por [Andrew Abela](https://extremepresentation.com/wp-content/uploads/choosing-a-good-chart-09-1.pdf)) em que √© poss√≠vel perceber que os gr√°ficos mais comuns podem ser dividos em **4 subgrupos**:

- Compara√ß√£o
- Distribui√ß√£o
- Relacionamento
- Composi√ß√£o

<img src="https://i.imgur.com/u77CgCq.png" alt="inserir alt" height="720" width="900">

<font size=2>Fonte: Andrew Abela (Extreme Presentation/Biuwer)</font>

### <font color=#E6ae1d size=5>Compara√ß√£o üìä</font>


---

√â amplamente utilizado quando queremos **comparar diferentes valores e atributos** dentro dos dados, uns com os outros. 

O tipo pode variar dependendo dos dados. Por exemplo: 

- Os nossos dados possuem uma vari√°vel temporal? 
 - Quantos per√≠odos de tempo possu√≠mos?
- Quantas vari√°veis e categorias os nossos dados apresentam? 

<font color=green> Visualiza√ß√µes mais comuns: </font> Gr√°ficos de colunas, barras e linhas

#### Gr√°fico de Barras
"""

## Configurando o gr√°fico com par√¢metros que potencializam a visualiza√ß√£o dos dados

# √Årea da visualiza√ß√£o e ocultar as bordas do gr√°fico exceto a do lado esquerdo
plt.figure(figsize=(15, 8))
custom_params = {"axes.spines.right": False, "axes.spines.top": False, 
                 "axes.spines.bottom": False}

# Tema mais limpo para a visualiza√ß√£o com os par√¢metros previamente descritos
sns.set_theme(context="notebook", style="white", rc=custom_params)

# Destacando o TOP 3 estados com maior quantidade de aplicantes
estados = enem["UF_PROVA"].value_counts().index
top_3 = estados[:3]
cores = ["#6495ed" if (estado in top_3) else "#cddbf3" for estado in estados]

# Plotando o gr√°fico de barras e ocultando os pontos do eixo X
ax = sns.countplot(data = enem, y = "UF_PROVA", order = enem["UF_PROVA"].value_counts().index, palette = cores)
ax.set_xticklabels([])

# Adicionando t√≠tulo e subt√≠tulo no gr√°fico e ocultando as labels de cada eixo
plt.suptitle("Qual √© o TOP 3 estados em n√∫mero de aplicantes na Regi√£o Nordeste?", size = 18, weight='bold')
plt.title("ENEM - 2010 a 2017", fontsize = 16, pad = 15)
plt.ylabel("")
plt.xlabel("")

# Escrevendo os valores de cada barra (eixo X) no gr√°fico
for index, barra in enumerate(ax.patches):
  pos_x = barra.get_width()
  pos_y = barra.get_y() + barra.get_height() / 2
  offset = 2000
  quantidade = f'{pos_x:,.0f}'.replace(',','.')
  ax.text(x = pos_x + offset , y = pos_y, s = quantidade, va='center', fontsize=14)

"""<font color=green size=4> Observa√ß√µes e hip√≥teses: </font>

---

Podemos facilmente observar a quantidade de aplicantes do Enem relativo a cada estado no per√≠odo de 2010 a 2017. Al√©m disso, podemos apontar a **Bahia, Cear√° e Pernambuco** como o **TOP 3** estados com mais aplicantes. 

Seria interessante tra√ßar um paralelo com a popula√ß√£o de cada estado ou com o n√∫mero de estudantes nesses dados estados atrav√©s de fontes externas, como a do IBGE.

#### Gr√°fico de Colunas
"""

## Configurando o gr√°fico com par√¢metros que potencializam a visualiza√ß√£o dos dados

# √Årea da visualiza√ß√£o e ocultar as bordas do gr√°fico exceto a do eixo X
plt.figure(figsize=(15, 8))
custom_params = {"axes.spines.right": False,"axes.spines.left": False,
                 "axes.spines.top": False}

# Tema mais limpo para a visualiza√ß√£o com os par√¢metros previamente descritos
sns.set_theme(context="notebook", style="white", rc=custom_params)

# Ajustando a identidade visual dos gr√°ficos
cores = ["#6495ed","#cddbf3"]

# Selecionando apenas os 3 estados com o maior n√∫mero de aplicantes e eliminando
# os casos que apresentam de maneira inconclusiva o tipo de l√≠ngua (".")
top_3 = ["BA", "CE", "PE"]
enem_top3_linguas = enem[-(enem["TIPO_LINGUA"] == ".")].query("UF_PROVA == @top_3")

# Plotando o gr√°fico de colunas, ocultando os pontos do eixo Y e definindo as 
# vari√°veis categ√≥ricas do eixo X (estados)
ax = sns.countplot(data = enem_top3_linguas.sort_values("UF_PROVA"), x = "UF_PROVA", 
                   hue= "TIPO_LINGUA", hue_order = ["Espanhol","Ingl√™s"], palette = cores)
ax.set_yticklabels([])
ax.set_xticklabels(["Bahia", "Cear√°", "Pernambuco"], fontsize = 14)

# Adicionando t√≠tulo e subt√≠tulo no gr√°fico e ocultando as labels de cada eixo
plt.suptitle("Qual √© o idioma preferido do TOP 3 estados?", size = 18, weight='bold')
plt.title("ENEM - 2010 a 2017", fontsize = 16, pad = 15)
plt.ylabel("")
plt.xlabel("")

# Descrevendo o limite m√≠nimo e m√°ximo do eixo Y
plt.ylim(0, 150000)

# Escrevendo os valores de cada coluna (eixo Y) no gr√°fico
for index, barra in enumerate(ax.patches):
  pos_x = barra.get_x() + barra.get_width() / 2
  pos_y = barra.get_height()
  offset = 2000
  quantidade = f'{pos_y:,.0f}'.replace(',','.')  
  ax.text(x = pos_x, y = pos_y + offset, s = quantidade, ha='center', fontsize=14)

"""<font color=green size=4> Observa√ß√µes e hip√≥teses: </font>

---

Ap√≥s apresentarmos os estados da **Bahia, Cear√° e Pernambuco** como o **TOP 3** estados com mais aplicantes, √© poss√≠vel, atrav√©s do gr√°fico de colunas, verificar a quantidade aplicantes de acordo com a escolha de idioma estrangeiro (Espanhol e Ingl√™s) em cada estado.

Podemos observar que os tr√™s estados possuem a **l√≠ngua espanhola** como a **escolha preferida** das(os) aplicantes. O estado do **Cear√°** apresenta a maior propor√ß√£o entre as duas l√≠nguas (aproximadamente **74%** e **26%**, para a l√≠ngua espanhola e inglesa respectivamente).

#### Gr√°fico de linhas
"""

# Retirando as notas NaN do subset das Notas de Ci√™ncias Humanas
enem_ch = enem.dropna(subset=["NOTA_CIENCIAS_HUMANAS"])

# Selecionado as colunas relevantes para an√°lise e apenas as notas das provas
# realizadas na Bahia
colunas = ["ANO", "UF_PROVA", "NOTA_CIENCIAS_HUMANAS"]
enen_ch_BA = enem_ch[colunas].query("UF_PROVA == 'BA'")

# Agregando as notas e calculando a m√©dia da mat√©ria pro ano 
enen_ch_BA = enen_ch_BA.groupby(["ANO"]).aggregate("mean")

# Ajustando o DataFrame para apresentar a vari√°vel ANO como coluna e n√£o index
enen_ch_BA = enen_ch_BA.reset_index()

## Configurando o gr√°fico com par√¢metros que potencializam a visualiza√ß√£o dos dados

# √Årea da visualiza√ß√£o e ocultar as bordas do gr√°fico exceto as do Eixo X e Y
plt.figure(1, figsize=(24, 8))
custom_params = {"axes.spines.right": False, "axes.spines.top": False}

# Tema mais limpo para a visualiza√ß√£o com os par√¢metros previamente descritos
sns.set_theme(context="notebook", style="white", rc=custom_params)

# Ajustando a identidade visual dos gr√°ficos
sns.set_palette("light:#6495ed_r")

# Criando vari√°veis que guardam a nota m√≠nima, m√°xima, o array com todas as notas por ano
# e os pontos a serem destacados pelo marcador
nota_min = min(enen_ch_BA["NOTA_CIENCIAS_HUMANAS"])
nota_max = max(enen_ch_BA["NOTA_CIENCIAS_HUMANAS"])
valores = enen_ch_BA["NOTA_CIENCIAS_HUMANAS"].values
pontos_a_marcar = list((valores == nota_min) | (valores == nota_max))

# Adicionando t√≠tulo no gr√°fico
plt.suptitle("Qual a m√©dia das notas dos aplicantes do estado da Bahia em Ci√™ncias Humanas?", size = 18, weight='bold')

## GR√ÅFICO 01 - DESCREVENDO O INTERVALO M√çNIMO E M√ÅXIMO DE Y

# Definindo o gr√°fico 01
plt.subplot(121)

# Plotando o gr√°fico de linha e selecionando os pontos de m√°ximo e m√≠nimo
ax = sns.lineplot(data = enen_ch_BA, x = "ANO", y = "NOTA_CIENCIAS_HUMANAS", 
                  marker ="o", markersize = 10, markerfacecolor = "grey",
                  markevery = pontos_a_marcar)

# Adicionando subt√≠tulo no gr√°fico e ocultando as labels de cada eixo
plt.title("Com intervalos m√°ximo e m√≠nimo definidos", fontsize = 16, pad = 20)
plt.ylabel("M√©dia", fontsize = 14)
plt.xlabel("Ano", fontsize = 14)

# Adicionando o texto para a maior e a menor m√©dia e o ano em que ocorreram
for x, y in zip(enen_ch_BA["ANO"], enen_ch_BA["NOTA_CIENCIAS_HUMANAS"]):
  if y == max(enen_ch_BA["NOTA_CIENCIAS_HUMANAS"]):
    ax.text(x = x + 0.1, y = y + 10, s = f"Maior M√©dia = {y:.2f} ({x:})", color = "green", 
           weight = "bold", fontsize = 14)
  if y == min(enen_ch_BA["NOTA_CIENCIAS_HUMANAS"]):
    ax.text(x = x + 0.1, y = y - 20, s = f"Menor M√©dia = {y:.2f} ({x:})", color = "red", 
           weight = "bold", fontsize = 14)

# Descrevendo o limite m√≠nimo e m√°ximo do eixo y
plt.ylim(0, 700)

## GR√ÅFICO 02 - SEM DESCREVER O INTERVALO M√çNIMO E M√ÅXIMO

# Definindo o gr√°fico 02
plt.subplot(122)

# Plotando o gr√°fico de linha e selecionando os pontos de m√°ximo e m√≠nimo
ax = sns.lineplot(data = enen_ch_BA, x = "ANO", y = "NOTA_CIENCIAS_HUMANAS", 
                  marker ="o", markersize = 10, markerfacecolor = "grey",
                  markevery = pontos_a_marcar)

# Adicionando subt√≠tulo no gr√°fico e ocultando as labels de cada eixo
plt.title("Sem intervalos m√°ximo e m√≠nimo definidos", fontsize = 16, pad = 20)
plt.ylabel("")
plt.xlabel("Ano", fontsize = 14)

# Adicionando o texto para a maior e a menor m√©dia e o ano em que ocorreram
for x, y in zip(enen_ch_BA["ANO"], enen_ch_BA["NOTA_CIENCIAS_HUMANAS"]):
  if y == max(enen_ch_BA["NOTA_CIENCIAS_HUMANAS"]):
    ax.text(x = x + 0.1, y = y + 3, s = f"Maior M√©dia = {y:.2f} ({x:})", color = "green", 
           weight = "bold", fontsize = 14)
  if y == min(enen_ch_BA["NOTA_CIENCIAS_HUMANAS"]):
    ax.text(x = x + 0.1, y = y - 3, s = f"Menor M√©dia = {y:.2f} ({x:})", color = "red", 
           weight = "bold", fontsize = 14)

# Inserindo um espa√ßo entre gr√°ficos
plt.tight_layout(pad=5)

# Exibindo os gr√°ficos
plt.show()

"""<font color=red size=5> ‚ö† CUIDADO! ‚ö†</font>

> Muitas ferramentas tentam ajustar os dados de **m√°ximo** e **m√≠nimo** para aproveitar o m√°ximo da √°rea escolhida para o desenho do gr√°fico.
>
> Em muitos casos, esse tipo de comportamento pode nos levar a uma interpreta√ß√£o equivocada de nossos dados, fazendo com que eles pare√ßam mais discreptantes do que realmente s√£o.

<font color=green size=4> Observa√ß√µes e hip√≥teses: </font>

---
O gr√°fico de linhas apresenta as m√©dias de Ci√™ncias Humanas no estado da Bahia.

Podemos destacar dois pontos importantes para analisar a evolu√ß√£o das m√©dias pelos anos: a **menor m√©dia** registrada √© de **463,13** no ano de 2011 e a **maior m√©dia** √© de **549,99** no ano de 2015. A diferen√ßa entre as duas m√©dias √© de aproximadamente **87 pontos**. 

Vale a pena verificar se esse comportamento √© semelhante ao de outros estados ou um caso particular desse estado.

---

### <font color=#4b6cd4 size=5>Distribui√ß√£o üßÆ</font>


---

√â utilizado quando queremos entender **como as observa√ß√µes individuais s√£o distribu√≠das** dentro de nosso conjunto de dados. 

O tipo pode variar dependendo dos dados. Por exemplo: 
- Quantas vari√°veis estou representando? 
- Possuo muitas ou poucas observa√ß√µes?

<font color=green> Visualiza√ß√µes mais comuns: </font> histogramas de colunas e linhas e gr√°ficos de dispers√£o.

#### Histograma de barras
"""

# Retirando as idades NaN da coluna IDADE
enem_idade =  enem["IDADE"].dropna()

# Selecionado o intervalo das idades das(os) aplicantes de 15 a 60 anos 
selecao = (enem_idade >= 15) & (enem_idade <= 60)
enem_idade = enem_idade[selecao]

## Configurando o gr√°fico com par√¢metros que potencializam a visualiza√ß√£o dos dados

# √Årea da visualiza√ß√£o e ocultar as bordas do gr√°fico exceto os eixos X e Y
plt.figure(figsize=(15, 8))
custom_params = {"axes.spines.right": False, "axes.spines.top": False}

# Tema mais limpo para a visualiza√ß√£o com os par√¢metros previamente descritos
sns.set_theme(context="notebook", style="white", rc=custom_params)

# Ajustando a identidade visual dos gr√°ficos
sns.set_palette("light:#6495ed_r")

# Plotando o histograma de colunas e ajustando os pontos do eixo X
ax = plt.hist(x = enem_idade, bins = 40)
plt.xticks(list(np.arange(15, 65, step=5)))

# Adicionando t√≠tulo e subt√≠tulo em nosso gr√°fico e o nome das labels
plt.suptitle(" Qual a distribui√ß√£o das idades de aplicantes?", size = 18, weight='bold')
plt.title("ENEM - 2010 a 2017", fontsize = 16, pad = 15)
plt.ylabel("Quantidade", fontsize = 14)
plt.xlabel("Idade", fontsize = 14)

# Oculta as informa√ß√µes no topo do gr√°fico
plt.show()

"""<font color=green size=4> Observa√ß√µes e hip√≥teses: </font>

---
O **Enem** √© um exame de avalia√ß√£o da aprendizagem de estudantes do **Ensino M√©dio** de todo Brasil, mas tamb√©m √© uma ferramenta importante para quem visa o acesso √†s universidades e faculdades de todo o pa√≠s. Por isso, √© esperado que uma grande parte dos aplicantes esteja entre as idades de **15 a 20 anos**.

O histograma aponta essa situa√ß√£o, mas podemos tamb√©m sugerir uma aten√ß√£o aos(√†s) estudantes **por volta dos 25 anos**. Uma das hip√≥teses √© a de aplicantes buscando uma possibilidade de acesso √† uma segunda gradua√ß√£o ou uma mudan√ßa de carreira seguida da tentativa de altera√ß√£o do tipo de curso que desejam estudar.

---

### <font color=#da5459 size=5>Relacionamento üîÄ</font>


---

√â indicado quando estamos interessados em saber **como os valores e atributos est√£o se relacionando entre si**. 

Para esse tipo, os **gr√°ficos de dispers√£o** geralmente s√£o usados quando tra√ßamos a rela√ß√£o entre **duas vari√°veis**, e os **gr√°ficos de bolhas** quando **tr√™s vari√°veis** est√£o envolvidas.

<font color=green> Visualiza√ß√µes mais comuns: </font> Gr√°ficos de dispers√£o e gr√°ficos de bolhas

#### Gr√°fico de Dispers√£o (Scatter plot)
"""

# Retirando as notas NaN das colunas das notas de Matem√°tica e Ci√™ncias da Natureza
enem_mat_cn = enem[["NOTA_MATEMATICA","NOTA_CIENCIAS_NATUREZA"]].dropna()

# Selecionando todas as notas de Matem√°tica e Ci√™ncias da Natureza exceto as de valor 0
enem_mat_cn = enem_mat_cn.query("NOTA_MATEMATICA != 0 & NOTA_CIENCIAS_NATUREZA != 0").reset_index(drop = True)

"""<font color=red size=5> ‚ö† CUIDADO! ‚ö†</font>

> O **gr√°fico de dispers√£o** (Scatter Plot) √© usado para verificar se existe uma **rela√ß√£o entre duas vari√°veis num√©ricas**.
>
> Isso n√£o significa que uma vari√°vel causa efeito na outra, mas apenas se existe uma rela√ß√£o e qual intensidade entre essa rela√ß√£o. A rela√ß√£o entre duas vari√°veis pode ser **positiva**, **negativa** ou **neutra**, **linear** ou **n√£o linear**.


> Outra aten√ß√£o que devemos ter √© em rela√ß√£o ao **overplotting**. 
>
>De forma resumida, o overplotting √© quando os **dados ou labels em uma visualiza√ß√£o de dados se sobrep√µem**, tornando dif√≠cil de notar cada observa√ß√£o dos dados individualmente em uma visualiza√ß√£o de dados. Ele normalmente acontece quando temos um **grande n√∫mero de observa√ß√µes** ou um **n√∫mero restrito de valores √∫nicos** em nosso dataset.
"""

# Selecionando uma amostra aleat√≥ria de 1000 notas do nosso DataFrame, para evitar o overplotting 
enem_mat_cn = enem_mat_cn.sample(n=1000)

## Configurando o gr√°fico com par√¢metros que potencializam a visualiza√ß√£o dos dados

# √Årea da visualiza√ß√£o e ocultar as bordas do gr√°fico exceto os eixos X e Y
plt.figure(figsize=(11, 8))
custom_params = {"axes.spines.right": False, "axes.spines.top": False}

# Tema mais limpo para a visualiza√ß√£o com os par√¢metros previamente descritos
sns.set_theme(context="notebook", style="white", rc=custom_params)

# Ajustando a identidade visual dos gr√°ficos
sns.set_palette("light:#6495ed_r")

# Plotando o gr√°fico de dispers√£o com a amostra de pontos escolhidos aleatoriamente
ax = sns.scatterplot(data = enem_mat_cn, x = "NOTA_MATEMATICA", y = "NOTA_CIENCIAS_NATUREZA")

# Adicionando t√≠tulo e subt√≠tulo em nosso gr√°fico e o nome dos labels
plt.suptitle("Qual a distribui√ß√£o das Notas de Matem√°tica em rela√ß√£o √†s de Ci√™ncias da Natureza?", size = 16, weight='bold')
plt.title("ENEM - 2010 a 2017", fontsize = 14, pad = 15)
plt.ylabel("Nota de Ci√™ncias da Natureza", fontsize = 14, labelpad = 15)
plt.xlabel("Nota de Matem√°tica", fontsize = 14, labelpad = 15)

# Descrevendo o limite m√≠nimo e m√°ximo do eixo x e y
plt.xticks(list(np.arange(200, 1100, step=100)))
plt.yticks(list(np.arange(200, 1100, step=100)))

# Oculta as informa√ß√µes no topo do gr√°fico
plt.show()

"""<font color=green size=4> Observa√ß√µes e hip√≥teses: </font>

---

Se observarmos o gr√°fico de dispers√£o das notas de **Matem√°tica** e **Ci√™ncias da Natureza**, podemos notar certa semelhan√ßa entre elas. Quando a nota de Matem√°tica **aumenta**, a nota de Ci√™ncias tende a **subir**, e quando a nota de Matem√°tica **diminui**, a nota de Ci√™ncias tende a **cair**. 

Logo, podemos inferir que a rela√ß√£o entre as vari√°veis √© **positiva**.

#### Gr√°fico de Bolhas
"""

# Retirando as notas NaN das colunas das selecionadas
colunas = ["UF_PROVA", "IDADE", "NOTA_MATEMATICA","NOTA_LINGUAGENS_CODIGOS", "NOTA_REDACAO"]
enem_mat_pt_red = enem[colunas].dropna()

# Selecionando todas as notas de Matem√°tica, Linguagens e C√≥digos e Reda√ß√£o exceto as de valor 0
enem_mat_pt_red = enem_mat_pt_red.query("NOTA_MATEMATICA != 0 & NOTA_LINGUAGENS_CODIGOS != 0 & NOTA_REDACAO != 0").reset_index(drop = True)

# Agrupando os dados por estado e idade dos aplicantes
enem_mat_pt_red = enem_mat_pt_red.groupby(["UF_PROVA", "IDADE"]).aggregate("mean")

## Configurando o gr√°fico com par√¢metros que potencializam a visualiza√ß√£o dos dados

# √Årea da visualiza√ß√£o e ocultar as bordas do gr√°fico exceto os eixos X e Y
plt.figure(figsize=(11, 8))
custom_params = {"axes.spines.right": False, "axes.spines.top": False}

# Tema mais limpo para a visualiza√ß√£o com os par√¢metros previamente descritos
sns.set_theme(context="notebook", style="white", rc=custom_params)

# Plotando o gr√°fico de bolhas com as notas de reda√ß√£o como o tamanho das bolhas
ax = sns.scatterplot(data = enem_mat_pt_red, x = "NOTA_MATEMATICA", y = "NOTA_LINGUAGENS_CODIGOS", 
                     size = "NOTA_REDACAO", hue = "NOTA_REDACAO", sizes=(10, 200), 
                     palette = "Blues")

# Adicionando t√≠tulo e subt√≠tulo em nosso gr√°fico e o nome dos labels
plt.suptitle("Qual a distribui√ß√£o das Notas de Matem√°tica, Linguagens e C√≥digos em rela√ß√£o √†s de Reda√ß√£o?", size = 16, weight='bold')
plt.title("ENEM - 2010 a 2017", fontsize = 14, pad = 15)
plt.ylabel("Nota de Linguagens e C√≥digos", fontsize = 14, labelpad = 15)
plt.xlabel("Nota de Matem√°tica", fontsize = 14, labelpad = 15)
ax.legend(loc = 'lower right', title='Nota de Reda√ß√£o', title_fontsize  = 14, fontsize = 14)

# Descrevendo o limite m√≠nimo e m√°ximo do eixo x e y
plt.xticks(list(np.arange(300, 800, step=100)))
plt.yticks(list(np.arange(300, 800, step=100)))

# Oculta as informa√ß√µes no topo do gr√°fico
plt.show()

"""<font color=green size=4> Observa√ß√µes e hip√≥teses: </font>

---

Se observarmos o gr√°fico de dispers√£o da m√©dia de **Matem√°tica**, **Linguagens e C√≥digos** e **Reda√ß√£o**, n√£o √© poss√≠vel notar uma tend√™ncia clara entre elas.

Assim, podemos apontar que a rela√ß√£o entre as vari√°veis aparentemente √© **neutra**.

---

### <font color=#9c82b6 size=5>Composi√ß√£o üì¶</font>


---

√â utilizado quando queremos saber **como os dados s√£o compostos**, ou seja, quais caracter√≠sticas gerais est√£o presentes no conjunto de dados. 

Existem algumas varia√ß√µes dependendo dos dados. Por exemplo:
- Os nossos dados s√£o din√¢micos (mudam de acordo com o tempo)? 
  - Quantos per√≠odos de tempo possu√≠mos?
- Em dados est√°ticos, n√≥s temos valores que s√£o acumulados?

<font color=green> Visualiza√ß√µes mais comuns: </font> Gr√°ficos de colunas empilhadas, √°rea e de pizza

#### Gr√°fico de Pizza
"""

# Gerando um DataFrame com o nome dos estado ordenados com a quantidade de aplicantes
enem_qtd = pd.DataFrame({"UF": enem["UF_PROVA"].value_counts().index,
                         "QTD": enem["UF_PROVA"].value_counts().values})

# Renomeando todos os estados que n√£o s√£o das principais sedes como 'Outros'
enem_qtd.loc[enem_qtd["QTD"] < 120000, "UF"] = 'Outros'

# Gerando o gr√°fico de pizza com as nossas principais sedes em rela√ß√£o a todo Nordeste
fig = px.pie(enem_qtd, values="QTD", names='UF', title='Propor√ß√£o de aplicantes no Nordeste (em %)', 
             width=700, height=525, color = 'UF',
             color_discrete_map={"BA": "#83aaf0",
                                 "CE": "#a8c3f2",
                                 "PE": "#cddbf3",
                                 "Outros": "#f3f3f4"})
# Escrevendo os labels e percentuais
fig.update_traces(textposition='inside', textinfo='percent+label',
                  marker=dict(line=dict(color='#FFFFFF', width=1)))

# Ocultando a legenda
fig.update(layout_showlegend=False)

"""<font color=green size=4> Observa√ß√µes e hip√≥teses: </font>

---

Se analisarmos os estados com mais aplicantes, podemos verificar que eles juntos apresentam **em torno de 60% de todas(os) (as)os aplicantes** do Enem. Outro fator curioso √© de que o estado da **Bahia** ostenta quase **1/4** de todos(as) os(as) aplicantes da Regi√£o Nordeste.

Semelhante ao 1¬∫ questionamento, seria interessante tra√ßar um paralelo com a popula√ß√£o de cada estado ou com o n√∫mero de estudantes nesses dados estados atrav√©s de fontes externas, como a do IBGE por exemplo.

#### Barras empilhadas
"""

# Selecionado as colunas relevantes para an√°lise
enem_situacao = enem[["ANO", "SITUACAO_CONCLUSAO"]]

# Criando uma tabela cruzada com cada situa√ß√£o separada por ano
enem_aplicantes = pd.crosstab(index=enem_situacao["ANO"], columns=enem_situacao['SITUACAO_CONCLUSAO'])
enem_aplicantes

"""#### Barras empilhadas (diferen√ßas absolutas e relativas importam)"""

## Configurando o gr√°fico com par√¢metros que potencializam a visualiza√ß√£o dos dados

# Ocultar as bordas do gr√°fico exceto a dos eixos x e y
custom_params = {"axes.spines.right": False, "axes.spines.top": False}

# Tema mais limpo para a visualiza√ß√£o com os par√¢metros previamente descritos
sns.set_theme(context="notebook", style="white", rc=custom_params)

# Ajustando a identidade visual dos gr√°ficos
sns.set_palette("light:#6495ed", 4)

# Plotando o gr√°fico de barras empilhadas e ajustando a legenda
ax = enem_aplicantes.plot(kind='barh', stacked = True, figsize= (15, 8), alpha  = 0.8)
ax.legend(title='Situa√ß√£o de Conclus√£o', title_fontsize  = 12, fontsize = 12)
      
# Adicionando t√≠tulo e subt√≠tulo em nosso gr√°fico
plt.suptitle("Como est√£o divididos os aplicantes do Enem do ponto de vista acad√™mico em cada ano?", size = 18, weight='bold')
plt.title("ENEM - 2010 a 2017", fontsize = 16, pad = 15)
plt.ylabel("Ano", fontsize = 14, labelpad = 15)
plt.xlabel("Quantidade de aplicantes", fontsize = 14, labelpad = 15)

# Oculta as informa√ß√µes no topo do gr√°fico
plt.show()

"""<font color=green size=4> Observa√ß√µes e hip√≥teses: </font>

---
Atrav√©s do gr√°fico de barras empilhadas, podemos observar as rela√ß√µes **absolutas** (quantidade aplicantes por ano) e **relativas** (situa√ß√µes de conclus√£o) das(os) aplicantes do Enem dentro do per√≠odo de 2010 a 2017. Podemos notar que a situa√ß√£o *Conclu√≠do* apresenta uma predomin√¢ncia nos nossos dados em cada ano.

Entretanto, o gr√°fico mais adequado para saber a rela√ß√£o entre as situa√ß√µes e a propor√ß√£o delas, em cada ano, √© o gr√°fico de barras 100% empilhadas, que veremos mais abaixo.

#### Barras 100% empilhadas
"""

## Configurando o gr√°fico com par√¢metros que potencializam a visualiza√ß√£o dos dados

# Ocultar as bordas do gr√°fico exceto a dos eixos y
custom_params = {"axes.spines.right": False, "axes.spines.top": False, 
                 "axes.spines.bottom": False}

# Tema mais limpo para a visualiza√ß√£o com os par√¢metros previamente descritos
sns.set_theme(context="notebook", style="white", rc=custom_params)

# Ajustando a identidade visual dos gr√°ficos
sns.set_palette("light:#6495ed", 4)

# Criando uma tabela cruzada com a propor√ß√£o de cada situa√ß√£o separada por ano
enem_aplicantes_prop = pd.crosstab(index=enem_situacao["ANO"], columns=enem_situacao['SITUACAO_CONCLUSAO'], 
                                   normalize="index")

# Plotando o gr√°fico de barras 100% empilhadas e ajustando a legenda
ax = enem_aplicantes_prop.plot(kind='barh', stacked=True, figsize= (15, 8), alpha  = 0.8)
ax.legend(bbox_to_anchor=(1.005, 1), title='Situa√ß√£o de Conclus√£o', title_fontsize  = 12, fontsize = 12)
ax.set_xticklabels([])
    
# Adicionando t√≠tulo e subt√≠tulo em nosso gr√°fico
plt.suptitle("Qual a propor√ß√£o da situa√ß√£o dos aplicantes do Enem por ano?", size = 18, weight='bold')
plt.title("ENEM - 2010 a 2017", fontsize = 16, pad = 15)
plt.ylabel("Ano", fontsize = 14, labelpad = 15)
plt.xlabel("100%", fontsize = 18, labelpad = 15)

# Ajustando a posi√ß√£o do '100%' no eixo x
ax.xaxis.set_label_coords(0.95, 0)

# Adicionando as porcentagens em cada barra
for pos, valor in enumerate([*enem_aplicantes.index.values]):
    for (proporcao, count, pos_y) in zip(enem_aplicantes_prop.loc[valor],
                                          enem_aplicantes.loc[valor],
                                          enem_aplicantes_prop.loc[valor].cumsum()):
      if(count != 0):      
        plt.text(x = (pos_y - proporcao) + (proporcao / 2) - 0.005,
                y = pos - 0.05,
                s = f'{(proporcao * 100):.0f}%', 
                color="black", fontsize=12)

"""<font color=green size=4> Observa√ß√µes e hip√≥teses: </font>

---

Agora, com o gr√°fico de barras 100% empilhadas, o que √© destacado em nossos dados s√£o as **propor√ß√µes relativas** em cada ano. 

√â poss√≠vel notar que salvo o ano de 2013, em todos os anos, **60% ou mais das(os) aplicantes** j√° haviam conclu√≠do o Ensino M√©dio na √©poca das avalia√ß√µes do Enem.

2010, ano de in√≠cio do Enem com acesso ao SISU (Sistema de Sele√ß√£o Unificada), n√£o apresenta dados para aplicantes com a condi√ß√£o de *N√£o Conclu√≠do/N√£o cursando*.

---

## Links √öteis

*   [Infogram | Como escolher o gr√°fico certo para seus dados?](https://infogram.com/pt/pagina/escolha-grafico-de-visualizacoes-certo)
*   [Biuwer | Como escolher o melhor gr√°fico para os seus dados? (em ingl√™s e espanhol)](https://biuwer.com/en/blog/how-to-choose-the-right-chart-for-your-data/)
*   [Data Viz Project | Cole√ß√£o de visualiza√ß√µes de dados (em ingl√™s)](https://datavizproject.com/)
*   [From data to Viz | Ache o gr√°fico que precisa (em ingl√™s)](https://www.data-to-viz.com/)
*   [O Cat√°logo de Visualiza√ß√£o de Dados (em ingl√™s, espanhol e outras l√≠nguas)](https://datavizcatalogue.com/index.html)
*   [DisplayR Blog | O que √© Overplotting? (em ingl√™s)](https://www.displayr.com/what-is-overplotting/)
"""